# Scope and closures

Code associated to the `Scope and closures` lecture

## Objectives

### Variables scope
* Redefine key terms (scope resolution, lexical scope and execution context)
* `Lexical Scope(s)` (buckets and marbles)
* Relationship between `Lexical Scope` and `Scope Resolution`
* JS scopes: `Global`, `Function` and `Block` (p.s. `{}` can be a function body, block or object literal)
* A tour of JS variables
* Variables properties (scope, definition rules, 'hoisting' and debugger quirks)
* `var` variable overview
* `let` overview
* `cost` overview
* Comparing 'hoisting' for `var` vs `let`/`const`

### Closures
* First class functions
* Functions that return functions (like any other value)
* Closures as the natural outcome of first class functions and Lexical scope
* Debugger and closures

> **First class functions**: A programming language is said to have First-class functions when functions in that language are treated like any other variable. For example, in such a language, a function can be passed as an argument to other functions, can be returned by another function and can be assigned as a value to a variable. From `https://developer.mozilla.org/en-US/docs/Glossary/First-class_Function

> **Lexical scope**: Lexical scope means that scope is defined by author-time decisions of where functions are declared. From https://github.com/getify/You-Dont-Know-JS

> **Closure**: A closure is the combination of a function and the lexical environment within which that function was declared. From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures

> **Closure** definition by `@getify`: Closure is when a function is able to remember and access its lexical scope even when that function is executing outside its lexical scope.